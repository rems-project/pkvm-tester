type record =
| TestName of string
| SourceFile of string
| FunctionName of { name: string; start_line: int; end_line: int option }
| FunctionData of { name: string; count: int }
| FunctionsFound of int
| FunctionsHit of int
| BranchData of { line: int; block: int; branch: int; taken: int option }
| BranchesFound of int
| BranchesHit of int
| LineData of { line: int; count: int; checksum: string option }
| LinesFound of int
| LinesHit of int
| EndOfRecord

let pp_record =
  let open Fmt in
  let opt pp = option (const string "," ++ pp) in
  fun ppf -> function
  | TestName name -> pf ppf "TN:%s" name
  | SourceFile file -> pf ppf "SF:%s" file
  | FunctionName r -> pf ppf "FN:%d%a,%s" r.start_line (opt int) r.end_line r.name
  | FunctionData r -> pf ppf "FNDA:%d,%s" r.count r.name
  | FunctionsFound f -> pf ppf "FNF:%d" f
  | FunctionsHit h -> pf ppf "FNH:%d" h
  | BranchData r -> pf ppf "BRDA:%d,%d,%d,%a" r.line r.block r.branch
                      (option ~none:(const string "-") int) r.taken
  | BranchesFound f -> pf ppf "BRF:%d" f
  | BranchesHit h -> pf ppf "BRH:%d" h
  | LineData r -> pf ppf "DA:%d,%d%a" r.line r.count (opt string) r.checksum
  | LinesFound f -> pf ppf "LF:%d" f
  | LinesHit h -> pf ppf "LH:%d" h
  | EndOfRecord -> pf ppf "end_of_record"

module Fmap = Map.Make(Fpath)
module Smap = Map.Make(String)
module Imap = Map.Make(Int)

type file = { lines: int Imap.t          (**  line -> count  *)
            ; funcs: (int * int) Smap.t  (**  file -> line Ã— count  *) }
type info = file Fmap.t

let no_info = Fmap.empty
let (++) = Fmap.union @@ fun file f1 f2 ->
  let lines = Imap.union (fun _ x1 x2 -> Some (x1 + x2)) f1.lines f2.lines
  and funcs = Smap.union (fun func v1 v2 ->
    match v1, v2 with
    | (line1, _), (line2, _) when line1 <> line2 ->
        Fmt.invalid_arg "Lcov.(++): func %a:%s:%d redefined on line %d"
        Fpath.pp file func line1 line2
    | (line1, x1), (_, x2) -> Some (line1, x1 + x2))
    f1.funcs f2.funcs in
  Some { lines; funcs }

let line_hit ~file ~line count =
  let lines = Imap.singleton line count
  and funcs = Smap.empty in
  Fmap.singleton file { lines; funcs }

let func_hit ~file ~func ~startline count =
  let lines = Imap.empty
  and funcs = Smap.singleton func (startline, count) in
  Fmap.singleton file { lines; funcs }

let to_records info =
  let open Iters in
  let* path, f = ii Fmap.iter info in
  TestName "" @:
  SourceFile (Fpath.to_string path) @:
  ( let* name, (line, count) = ii Smap.iter f.funcs in
    FunctionName { name; start_line = line; end_line = None } @:
    FunctionData { name; count } @: nil ) ++
  ( FunctionsHit (Smap.cardinal f.funcs) @:
    FunctionsFound (Smap.cardinal f.funcs) @: nil ) ++
  ( let+ line, count = ii Imap.iter f.lines in
    LineData { line; count; checksum = None } ) ++
  ( LinesFound (Imap.cardinal f.lines) @:
    LinesHit (Imap.cardinal f.lines ) @:
    EndOfRecord @: nil )

let pp_info ppf info = 
  Fmt.pf ppf "@[<v>#generated by addr2lcov@,%a@]"
    Fmt.(iter ~sep:cut Iters.iter pp_record) (to_records info)
